#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>

#define SIZE_READ 4

char	*ft_strset(char *str, size_t n)
{
	char	*newl;
	char	*nul;

	newl = memchr(str, '\n', n);
	nul = strnchr(str, '\0');
	if (newl == NULL)
		return (nul);
	else if (nul == NULL)
		return (newl);
	else if (newl > nul)
		return (nul);
	else
		return (newl);
}

char	*get_next_line(int fd)
{
	static size_t	offset;
	int				bytes_read;//need signed variavl? for notice read return minus.
	char			buffer[SIZE_READ];
	char			*result;
	char			*copy_result;
	char			*newstr;
	size_t			forward_offset;
	size_t			b_start;
	size_t			bytes_new;
	char			flag_break;

	if (fd == -1)
	{
		write(1, "fd = -1", 7);
		return (NULL);
	}
	offset = 0;
	forward_offset = 0;
	copy_result = NULL;//COPY func OK??
	flag_break = 0;
	while (??)
	{
		bytes_read = read(fd, buffer, SIZE_READ);
		if (bytes_read < 0)
		{
			??
		}
		b_start = 0;
		forward_offset += bytes_read;
		if (offset < forward_offset)
		{
			b_start = SIZE_READ - (forward_offset - offset);
			newstr = ft_strset(&buffer[b_start], (SIZE_READ - b_start));
			if (newstr == NULL)
				bytes_new = SIZE_READ - b_start;
			else
			{
				bytes_new = newstr - &buffer[b_start] + 1;
				flag_break = 1;
			}
			newstr = ft_calloc((bytes_new + 1), sizeof(char)); //change calloc
			if (newstr == NULL)
			{
				return (NULL);
			}
			newstr = ??;//use copy func
			result = ft_strjoin(copy_result, newstr);
			free(copy_result);
			free(newstr);
			offset += bytes_new;
			if (flag_break == 1)
				break ;
			copy_result = result;
		}
	}
	return (result);
}

int main()
{
	int fd;

	fd = open("files", O_RDONLY);
	
}